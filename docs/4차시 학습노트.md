

> **20년차 개발자가 알려주는 AI × n8n 업무자동화 실전프로젝트**  
> **과정목표**: 개발의 필수 개념 공부를 통해 스스로 확장이 가능하도록 하고, 업무 자동화의 개념을 이해시키며, Backend 직접 구현을 통해서 개발에 대한 깊은 이해가 될 수 있도록 한다.

---

## 📚 4차시 학습 목표

1. **Node.js 개념과 JavaScript 필수 개념 이해**
2. **API의 중요성과 RESTful API 기본 구조 파악**
3. **CRUD 개념 이해 및 실습을 통한 Backend 구현**
4. **AI 시대 JavaScript의 중요성과 JSON 데이터 구조 이해**

---

## 🚀 4-1. Node.js 이해 및 환경 설정

### Node.js 개념

**정의**: Chrome V8 기반 JavaScript 런타임(브라우저 밖에서 JS 실행). 언어가 아님.

**특징**

- **이벤트 기반**: 비동기 이벤트 처리로 효율적인 서버 운영
- **논블로킹 I/O**: 동시에 여러 요청을 처리할 수 있어 성능 최적화
- **적은 자원으로 동시 요청 처리에 강함**: 실시간·API 서버에 적합

**n8n과의 관계**

- n8n은 Node.js 기반으로 구축되어 있음
- Code 노드 활용 시 JavaScript 이해가 필수
- 커스텀 기능 구현 및 동작 원리 이해에 도움

### AI 시대 JavaScript를 배워야 하는 이유

#### 1. **AI 코드 검증 능력**

- AI가 만든 코드의 오류 찾고 품질 판단하려면 JavaScript 기초가 필요
- AI는 완벽하지 않음. 결국 사람이 검토·수정해야 함

#### 2. **웹 개발의 독점적 지위**

- 브라우저에서 동작하는 유일한 프로그래밍 언어
- 모든 웹 애플리케이션과 사용자 인터페이스 개발의 기본
- 대체 불가능한 핵심 기술

#### 3. **AI 서비스 통합의 핵심**

- ChatGPT, Claude 등 AI API를 웹 애플리케이션에 연동
- AI 기반 서비스를 만들 때 JavaScript가 주력 언어

#### 4. **효과적인 AI 협업**

- 명확한 요구 전달과 생성 코드 커스터마이징을 위해 프로그래밍 개념·문법 이해가 필요

#### 5. **빠른 아이디어 구현**

- 진입 장벽 낮고 즉시 결과 확인 가능
- AI 도움으로 프로토타입 빠르게 만들고 반복 개선

### JSON (JavaScript Object Notation) 이해

#### 정의와 특징

**정의**: 데이터를 저장하고 교환(전송)하기 위한 **경량의 텍스트 기반 데이터 형식**

**특징**:

- 사람이 읽고 쓰기 쉬움
- 기계(컴퓨터)가 파싱(해석)하고 생성하기 쉬움
- 특정 언어에 종속되지 않아, 대부분의 API가 데이터 교환 표준으로 사용

#### 기본 구조

- `key: value` (키-값) 쌍으로 구성된 데이터의 모음
- `{}` (중괄호)로 객체를, `[]` (대괄호)로 배열을 표현
- **예시**: `{"name": "김해커", "age": 30, "isStudent": false}`

#### 중첩 구조 (Nested Data)

```javascript
// 실제 데이터 예시 - 사용자 정보를 표현하는 중첩 JSON 구조
{
  "user": {
    "id": "hacker123",
    "name": "김해커",
    "contact": { // 객체 속 객체
      "email": "hacker.kim@example.com",
      "phone": "010-1234-5678"
    },
    "skills": ["n8n", "AI", "JavaScript"], // 문자열 배열
    "projects": [ // 배열 속 객체
      {
        "projectName": "AI 기반 업무 자동화",
        "status": "진행중"
      },
      {
        "projectName": "사내 뉴스레터 자동 발송",
        "status": "완료"
      }
    ]
  }
}
```



## 🔧 개발 환경 설정: VS Code 추천 플러그인

### 1. Code Runner
**기능**: 특정 영역이나 파일을 바로 실행하여 결과를 볼수 있음
![[Pasted image 20250907165958.png]]

### 2. Quokka.js
**기능**: 'Live Scratchpad' for JavaScript. 코드 작성과 동시에 실행 결과를 에디터에 즉시 표시
**장점**: 간단한 코드 조각(snippet)이나 로직을 브라우저/터미널 실행 없이 빠르게 테스트하고 디버깅할 수 있음

![[Pasted image 20250907170046.png|425]]

---

## 🔧 4-2. JavaScript 필수 개념 확인

### 변수 선언과 ES6+ 기본 문법

#### 📦 변수 선언: const vs let

```javascript
// const: 재할당 불가능 (상수)
const name = '김철수';
const age = 25;
// name = '박영희'; // ❌ 에러!

// let: 재할당 가능
let score = 85;
score = 90; // ✅ 가능

// 객체/배열은 const여도 내부 수정 가능
const user = { name: '김철수', age: 25 };
user.age = 26; // ✅ 가능 (객체 내부 수정)
user.email = 'kim@example.com'; // ✅ 가능

const numbers = [1, 2, 3];
numbers.push(4); // ✅ 가능 (배열 내부 수정)
```

#### ✨ 화살표 함수 (Arrow Function)

```javascript
// 기존 방식
function add(a, b) {
  return a + b;
}

// 화살표 함수 - 기본형
const add = (a, b) => {
  return a + b;
};

// 화살표 함수 - 축약형 (한 줄 return)
const add = (a, b) => a + b;

// 매개변수가 하나일 때 괄호 생략 가능
const double = x => x * 2;

// 매개변수가 없을 때
const sayHello = () => 'Hello!';
```

#### 📝 Template Literal (백틱 문자열)

```javascript
const name = '김철수';
const age = 25;

// 기존 방식
const message = '안녕하세요, ' + name + '님! 나이는 ' + age + '세이시군요.';

// Template Literal
const message = `안녕하세요, ${name}님! 나이는 ${age}세이시군요.`;

// 계산도 가능
const result = `올해 말에는 ${age + 1}세가 됩니다.`;

// 여러 줄 문자열
const emailBody = `
  <h1>환영합니다, ${name}님!</h1>
  <p>가입일: ${new Date().toLocaleDateString()}</p>
`;
```

#### 스프레드 연산자 (...) 
- 배열이나 객체를 "펼쳐서" 개별 요소로 분해하는 기능을 제공
- iterable(반복 가능한) 객체를 개별 요소로 확장

```javascript
// 1. 배열을 다른 배열 메서드에 전달
const arr1 = [1, 2];
const arr2 = [3, 4, 5];

arr1.push(...arr2);
console.log(arr1); // [1, 2, 3, 4, 5]

// 2. 특정 속성만 업데이트 (기존 속성 유지 + 새 속성 추가)
const profile = { 
  id: 1, 
  name: '박민수', 
  email: 'park@example.com' 
};
const updatedProfile = { 
  ...profile,                                  // 기존 모든 속성 복사
  email: 'newpark@example.com',               // email만 덮어쓰기
  lastLogin: new Date(),                      // 새 속성 추가
  isActive: true                              // 새 속성 추가
};

// 3. 함수 호출 시 배열을 개별 인수로 전달
const numbers = [1, 2, 3];
Math.max(...numbers);                         // Math.max(1, 2, 3)과 동일
console.log(...numbers);                      // 1 2 3

```


### 구조분해 할당과 안전 연산자

#### 🎯 구조분해 할당 (Destructuring)

```javascript
const user = { 
  id: 1, 
  name: '김철수', 
  email: 'kim@example.com', 
  age: 25,
  address: {
    city: '서울',
    district: '강남구'
  }
};

// 기존 방식
const name = user.name;
const email = user.email;

// 구조분해 할당
const { name, email, age } = user;

// 별명 사용
const { name: userName, email: userEmail } = user;

// 기본값 설정
const { phone = '010-0000-0000' } = user;

// 중첩 객체 구조분해
const { address: { city, district } } = user;
```

#### 🛡️ 안전 연산자 (Optional Chaining & Nullish Coalescing)

```javascript
const user = {
  name: '김철수',
  address: {
    city: '서울',
    street: '테헤란로'
  }
};

// 옵셔널 체이닝 (?.)
const street = user.address?.street;
const zipCode = user.address?.zipCode; // undefined (에러 없음)
const countryCode = user.address?.country?.code;

// 널 병합 연산자 (??)
const safeAge = user.age ?? '나이 미상'; // null/undefined만 대체
const safeEmail = user.email ?? 'no-email@example.com';

// 옵셔널 체이닝과 함께 사용
const city = user.address?.city ?? '도시 미상';
```

### 배열/객체 처리 메서드

#### 🔍 배열 검색: find()

※ 딱 한가지 요소만 찾을때! 

```javascript
const users = [
  { id: 1, name: '김철수', age: 25, active: true },
  { id: 2, name: '박영희', age: 32, active: false },
  { id: 3, name: '이민수', age: 28, active: true }
];

// 특정 ID 사용자 찾기
const user = users.find(u => u.id === 2);
// 결과: { id: 2, name: '박영희', age: 32, active: false }

// 조건에 맞는 첫 번째 사용자 찾기
const firstActiveUser = users.find(u => u.active);

// 안전하게 사용하기
const targetUser = users.find(u => u.id === 2);
const userName = targetUser?.name ?? '사용자 없음';
```

#### 🔄 배열 변환: filter()와 map()

```javascript
// filter: 조건에 맞는 데이터만 걸러내기
const activeUsers = users.filter(user => user.active);
const youngUsers = users.filter(user => user.age < 30);

// map: 데이터 변환하기
const userNames = users.map(user => user.name);
// 결과: ['김철수', '박영희', '이민수']

const userCards = users.map(user => ({
  title: user.name,
  subtitle: `${user.age}세`,
  isActive: user.active
}));

// 메서드 체이닝: 여러 작업을 연결
const activeUserNames = users
  .filter(user => user.active)           // 1. 활성 사용자만
  .sort((a, b) => a.age - b.age)         // 2. 나이순 정렬
  .map(user => user.name);               // 3. 이름만 추출
```

#### 📋 객체 다루기: Object.keys(), Object.values, Object.entries()

```javascript
const user = {
  id: 1,
  name: '김철수',
  email: 'kim@example.com',
  age: 25
};

// 객체의 키들 가져오기
const keys = Object.keys(user);
// 결과: ['id', 'name', 'email', 'age']

// 객체의 값들 가져오기
const values = Object.values(user);
// 결과: ['김철수', 'kim@example.com', 25]

// 객체를 [키, 값] 배열로 변환
const entries = Object.entries(user);
// 결과: [['id', 1], ['name', '김철수'], ['email', 'kim@example.com'], ['age', 25]]

// entries를 활용한 객체 변환
const doubled = Object.fromEntries(
  Object.entries({ a: 1, b: 2, c: 3 }).map(([key, value]) => [key, value * 2])
);
// 결과: { a: 2, b: 4, c: 6 }
```

### ⏳ 비동기 처리 - async/await

#### 🤝 Promise란?

**Promise**는 비동기 작업의 **최종 성공 또는 실패를 나타내는 객체**입니다. "결과를 나중에 알려줄게\!"라는 '약속'과 같아요. Promise는 세 가지 상태를 가집니다.

  * **Pending (대기) 💬:** 약속의 결과가 아직 나오지 않은 초기 상태
  * **Fulfilled (이행) ✅:** 약속이 성공적으로 지켜진 상태 (결과값과 함께)
  * **Rejected (거부) ❌:** 약속이 지켜지지 못한 상태 (에러와 함께)

`async/await`는 이런 Promise를 더 쉽게 다룰 수 있게 해주는 최신 문법입니다. Promise의 `.then()`, `.catch()` 체이닝을 동기(순차적) 코드처럼 보이게 만들어 가독성을 높여줍니다.

#### 📝 Promise 기본 사용법 (.then/.catch)

Promise는 주로 `.then()`으로 성공 결과를, `.catch()`로 실패(에러)를 처리합니다.

```javascript
// 1. Promise 객체 생성
const myPromise = new Promise((resolve, reject) => {
  // 비동기 작업 시뮬레이션 (예: 1초 후 실행)
  setTimeout(() => {
    const success = true; // 작업 성공/실패 여부

    if (success) {
      // 성공 시 resolve 호출
      resolve({ id: 1, name: '김철수' }); 
    } else {
      // 실패 시 reject 호출
      reject(new Error('데이터를 불러오는 데 실패했습니다.'));
    }
  }, 1000);
});

// 2. Promise 사용
myPromise
  .then(user => {
    // Promise가 resolve되면 (성공하면) 실행될 코드
    console.log('성공:', user.name); // 결과: 성공: 김철수
    return user.name; // 다음 then으로 값을 넘길 수 있음
  })
  .then(name => {
    console.log(`${name}님 환영합니다!`); // 결과: 김철수님 환영합니다!
  })
  .catch(error => {
    // Promise가 reject되면 (실패하면) 실행될 코드
    console.error('실패:', error.message);
  });
```

#### 🔄 Promise와 async/await 기초

```javascript
// async 함수는 항상 Promise를 반환합니다.
async function getUserInfo(userId) {
  try {
    // await: Promise가 완료될 때까지 기다렸다가 결과값을 반환
    const response = await fetch(`https://api.example.com/users/${userId}`);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const user = await response.json();
    return user;
  } catch (error) {
    console.error('오류 발생:', error.message);
    return null; // 오류 발생 시 null 반환
  }
}

// 사용 예시
async function main() {
    const userData = await getUserInfo(1);
    const userName = userData?.name ?? '사용자 없음';
    console.log(userName);
}

main();
```

---
### 🤖 N8N Code Node에서 자주 사용하는 패턴

```javascript
// 입력 데이터 안전하게 가져오기
const items = $input.all();
const firstItem = items[0]?.json;

// 데이터 구조분해로 필요한 값 추출
const { userId, email, status } = firstItem ?? {};

// 안전한 데이터 처리 파이프라인
const result = items
  .filter(item => item.json?.status === 'active')
  .map(item => {
    const { id, name, email } = item.json ?? {};
    return {
      json: {
        userId: id,
        displayName: name?.toUpperCase() ?? 'Unknown',
        emailDomain: email?.split('@')[1] ?? 'unknown.com'
      }
    };
  });

return result;
```

---

## 🌐 4-3. API 소개

### API란 무엇일까요? 🤔

**API**는 **Application Programming Interface**의 약자 
간단히 말해 **'컴퓨터 프로그램들이 서로 소통하는 규칙'**

  - **Application (애플리케이션):** 우리가 사용하는 앱이나 웹사이트 (e.g., 인스타그램, 구글 지도)
  - **Programming (프로그래밍):** 컴퓨터가 알아듣는 언어로 명령을 내리는 것
  - **Interface (인터페이스):** 두 시스템을 연결해 주는 '접점'


### API를 왜 배워야 할까?


#### 식당 비유로 이해하는 API

```
고객 (클라이언트)  →  웨이터 (API)  →  주방 (서버)
     요청           ↙     ↘           응답
                   주문서 전달      요리 제공
```

![[Pasted image 20250915073402.png]]

- 만약 웨이터(API)가 없다면, 손님이 직접 주방에 들어가서 요리법을 배우고 재료를 찾아 요리해야 해야함
- **주방의 복잡한 내부 사정은 몰라도**, 정해진 메뉴판(규칙)을 보고 웨이터에게 주문만 하면 원하는 결과(요리)를 얻을 수 있음 

#### API가 필수인 이유

**1. 현대 서비스의 기반**
- ChatGPT, Google Maps, 카카오톡 등 모든 서비스가 API 기반
- 소셜 로그인, 결제 시스템, 지도 서비스 모두 API 연동

**2. n8n 자동화의 핵심**
- 거의 모든 n8n 노드가 API 기반으로 동작
- 외부 서비스 연동을 위한 필수 요소

### REST API 기본 개념

#### REST API란?

- **RE**presentational **S**tate **T**ransfer
- HTTP 프로토콜 활용
- 직관적이고 이해하기 쉬운 구조

#### HTTP URL 구조 분석

```
https://api.example.com/v1/todos/123
│       │              │   │     │
│       │              │   │     └─ 리소스 ID
│       │              │   └─ 리소스 이름 (복수형)
│       │              └─ 버전 정보  
│       └─ API 도메인
└─ 프로토콜 (HTTPS)
```

#### HTTP 메서드와 URL 패턴

|메서드|URL|설명|
|---|---|---|
|GET|`/api/todos`|모든 할 일 조회|
|GET|`/api/todos/123`|특정 할 일 조회|
|POST|`/api/todos`|새로운 할 일 생성|
|PUT|`/api/todos/123`|특정 할 일 수정|
|DELETE|`/api/todos/123`|특정 할 일 삭제|

### HTTP 상태 코드

#### 성공 코드 (2xx)

- `200 OK` - 요청 성공
- `201 Created` - 생성 성공
- `204 No Content` - 성공, 반환 데이터 없음

#### 클라이언트 오류 (4xx)

- `400 Bad Request` - 잘못된 요청
- `401 Unauthorized` - 인증 필요
- `404 Not Found` - 리소스 없음

#### 서버 오류 (5xx)

- `500 Internal Server Error` - 서버 내부 오류
- `503 Service Unavailable` - 서비스 이용 불가

### API 를 위한 VS Code 추천 플러그인

####  REST Client
- **기능**: VS Code 에디터에서 직접 HTTP 요청을 작성하고 보낼 수 있습니다. `.http` 또는 `.rest` 파일을 사용하여 요청을 관리합니다.
- **장점**: 간단한 텍스트 기반으로 API 요청을 명확하게 관리할 수 있으며, Postman과 같은 별도의 GUI 도구 없이 API를 테스트할 수 있어 편리합니다.

####  Thunder Client
- **기능**: Postman과 유사한 GUI 기반의 경량 REST API 클라이언트입니다.
- **장점**: 직관적인 UI를 통해 요청을 생성, 관리하고 응답을 확인할 수 있습니다. 별도의 프로그램을 설치할 필요 없이 VS Code 내에서 모든 API 테스트 작업을 완료할 수 있어 개발 워크플로우가 단순해집니다.

### JSON Server로 빠른 프로토타이핑

#### 빠른 API 개발을 위한 도구:

```bash
# JSON Server 설치
npm install -g json-server

# API 서버 실행
json-server --watch todos_db.json --port 3001
```

#### todos_db.json
- json_server용 구조 
```json
{
  "todos": [
    {
      "id": 1,
      "title": "json-server 학습하기",
      "completed": false
    },
    {
      "id": 2,
      "title": "REST API 개념 복습",
      "completed": true
    },
    {
      "id": 3,
      "title": "프로젝트 아이디어 구상",
      "completed": false
    }
  ]
}
```

**자동 생성되는 엔드포인트:**

- `GET /todos` - 모든 데이터 조회
- `POST /todos` - 새 데이터 생성
- `PUT /todos/:id` - 데이터 수정
- `DELETE /todos/:id` - 데이터 삭제
- `GET /todos/:id` - 특정 데이터 조회



### API 테스트 방법

#### 1. REST Client 확장 사용

**test.http 파일 생성:**

```http
### 모든 할 일 조회
GET http://localhost:3001/todos

### 새로운 할 일 생성
POST http://localhost:3001/todos
Content-Type: application/json

{
    "title": "REST Client로 테스트하기"
}

### 특정 할 일 조회  
GET http://localhost:3001/todos/1

### 할 일 수정
PUT http://localhost:3001/todos/1
Content-Type: application/json

{
    "title": "수정된 제목",
    "completed": true
}

### 할 일 삭제
DELETE http://localhost:3001/todos/1
```

#### 2. curl 명령어 사용

```bash
# 모든 할 일 조회
curl http://localhost:3001/todos

# 새로운 할 일 생성
curl -X POST http://localhost:3001/todos \
-H "Content-Type: application/json" \
-d '{"title": "새로운 할 일"}'

# 특정 할 일 조회 (추가됨)
curl http://localhost:3001/todos/1

# 할 일 수정 (수정됨)
curl -X PUT http://localhost:3001/todos/1 \
-H "Content-Type: application/json" \
-d '{"title": "수정된 할 일", "completed": true}'

# 할 일 삭제 (수정됨)
curl -X DELETE http://localhost:3001/todos/1
```



---

## 💻 4-4. CRUD 구현

### CRUD란?

데이터 조작의 4가지 기본 작업:

|작업|설명|HTTP 메서드|
|---|---|---|
|**C**reate|생성|POST|
|**R**ead|읽기|GET|
|**U**pdate|수정|PUT/PATCH|
|**D**elete|삭제|DELETE|

### Node.js Express TODO API 구현

#### 1. 프로젝트 설정

```bash
mkdir todo-api
cd todo-api
npm init -y
npm install express
```

#### 2. 기본 서버 구조 (app.js)

```javascript
const express = require('express');
const fs = require('fs');
const path = require('path');

const app = express();
const PORT = 3000;

// 미들웨어 설정
app.use(express.json());
// CORS 허용 (웹서버에서 호출 실패 방지)
app.use((req, res, next) => {
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
    res.header('Access-Control-Allow-Headers', 'Content-Type');
    next();
});

// 데이터 파일 관리
const DATA_FILE = path.join(__dirname, 'todos.json');

function readTodos() {
    try {
        const data = fs.readFileSync(DATA_FILE, 'utf8');
        return JSON.parse(data);
    } catch (error) {
        return [];
    }
}

function writeTodos(todos) {
    fs.writeFileSync(DATA_FILE, JSON.stringify(todos, null, 2));
}

app.listen(PORT, () => {
    console.log(`Server running on http://localhost:${PORT}`);
});
```

#### 3. CRUD 엔드포인트 구현

##### 초기 데이터 (todos.json)

```json
[
    {
        "id": 1,
        "title": "API 학습하기",
        "completed": false,
        "createdAt": "2024-01-01T00:00:00.000Z"
    },
    {
        "id": 2,
        "title": "CRUD 구현해보기", 
        "completed": false,
        "createdAt": "2024-01-01T00:00:00.000Z"
    }
]
```

##### CREATE - 새로운 할 일 추가

```javascript
app.post('/api/todos', (req, res) => {
    try {
        const todos = readTodos();
        const newTodo = {
            id: Date.now(),
            title: req.body.title,
            completed: false,
            createdAt: new Date().toISOString()
        };
        
        todos.push(newTodo);
        writeTodos(todos);
        
        res.status(201).json(newTodo);
    } catch (error) {
        res.status(500).json({ error: 'Failed to create todo' });
    }
});
```

##### READ - 할 일 조회

```javascript
// 모든 할 일 조회
app.get('/api/todos', (req, res) => {
    try {
        const todos = readTodos();
        res.json(todos);
    } catch (error) {
        res.status(500).json({ error: 'Failed to fetch todos' });
    }
});

// 특정 할 일 조회
app.get('/api/todos/:id', (req, res) => {
    try {
        const todos = readTodos();
        const todo = todos.find(t => t.id === parseInt(req.params.id));
        
        if (!todo) {
            return res.status(404).json({ error: 'Todo not found' });
        }
        
        res.json(todo);
    } catch (error) {
        res.status(500).json({ error: 'Failed to fetch todo' });
    }
});
```

##### UPDATE - 할 일 수정

```javascript
app.put('/api/todos/:id', (req, res) => {
    try {
        const todos = readTodos();
        const todoIndex = todos.findIndex(t => t.id === parseInt(req.params.id));
        
        if (todoIndex === -1) {
            return res.status(404).json({ error: 'Todo not found' });
        }
        
        todos[todoIndex] = {
            ...todos[todoIndex],
            title: req.body.title || todos[todoIndex].title,
            completed: req.body.completed !== undefined ? req.body.completed : todos[todoIndex].completed,
            updatedAt: new Date().toISOString()
        };
        
        writeTodos(todos);
        res.json(todos[todoIndex]);
    } catch (error) {
        res.status(500).json({ error: 'Failed to update todo' });
    }
});
```

##### DELETE - 할 일 삭제

```javascript
app.delete('/api/todos/:id', (req, res) => {
    try {
        const todos = readTodos();
        const todoIndex = todos.findIndex(t => t.id === parseInt(req.params.id));
        
        if (todoIndex === -1) {
            return res.status(404).json({ error: 'Todo not found' });
        }
        
        const deletedTodo = todos.splice(todoIndex, 1)[0];
        writeTodos(todos);
        
        res.json({ message: 'Todo deleted successfully', todo: deletedTodo });
    } catch (error) {
        res.status(500).json({ error: 'Failed to delete todo' });
    }
});
```

#### 5. Rest client 테스트 
**test.http 파일 생성:**

```http
### 모든 할 일 조회
GET http://localhost:3000/api/todos

### 새로운 할 일 생성
POST http://localhost:3000/api/todos
Content-Type: application/json

{
    "title": "REST Client로 테스트하기"
}

### 특정 할 일 조회  
GET http://localhost:3000/api/todos/1

### 할 일 수정
PUT http://localhost:3000/api/todos/1
Content-Type: application/json

{
    "title": "수정된 제목",
    "completed": true
}

### 할 일 삭제
DELETE http://localhost:3000/api/todos/1
```



---

## 🎯 실습 과제

### 과제 1: 북마크 API 만들기

다음 요구사항을 만족하는 북마크 API를 구현하세요:

**데이터 구조:**

```json
{
    "id": 1,
    "url": "https://example.com",
    "title": "예시 사이트",
    "description": "사이트 설명",
    "category": "개발",
    "createdAt": "2024-01-01T00:00:00.000Z"
}
```

**구현할 엔드포인트:**

- `GET /api/bookmarks` - 모든 북마크 조회
- `POST /api/bookmarks` - 새 북마크 생성
- `GET /api/bookmarks/:id` - 특정 북마크 조회
- `PUT /api/bookmarks/:id` - 북마크 수정
- `DELETE /api/bookmarks/:id` - 북마크 삭제

### 과제 2: API 테스트 케이스 작성

REST Client를 사용하여 만든 북마크 API의 모든 엔드포인트를 테스트하는 `.http` 파일을 작성하세요.

---

## 📝 핵심 정리

### 이번 차시에서 학습한 내용

#### 1. **JavaScript 필수 개념**

- ES6+ 문법(const/let, 화살표 함수, Template Literal)
- 구조분해 할당과 안전 연산자(?., ??)
- 배열/객체 처리 메서드(filter, map, find, entries)
- 비동기 처리(async/await)

#### 2. **API와 JSON의 이해**

- API의 중요성과 현대 개발에서의 역할
- REST API 설계 원칙과 HTTP 메서드
- JSON 데이터 구조와 중첩 데이터 처리
- n8n에서의 API 활용 방법

#### 3. **Backend 구현 경험**

- Node.js Express를 활용한 서버 구축
- CRUD 기능 완전 구현
- 에러 처리와 상태 코드 관리
- API 테스트 도구 활용

### 왜 이것들이 중요한가?

#### **개발의 기초 역량 확보**

- 모든 현대 애플리케이션의 기반이 되는 API 이해
- AI가 생성한 코드를 검증하고 수정할 수 있는 능력
- n8n 자동화에서 Code 노드 활용 능력

#### **Full Stack 개발 경험**

- Frontend 위주의 바이브코딩과 차별화
- Backend 직접 구현을 통한 깊은 이해
- 실제 서비스 개발 시 필요한 핵심 기술

#### **자기주도적 확장 가능**

- 기본 개념 이해를 바탕으로 스스로 학습 확장
- AI 도구와 효과적으로 협업할 수 있는 기반
- 업무 자동화를 실제로 적용할 수 있는 방법론

